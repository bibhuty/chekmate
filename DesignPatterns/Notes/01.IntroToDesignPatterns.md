
> The best way to use patterns is to load your brain with them and then recognise places in your designs and existing applications where you can apply them. Instead of code reuse, with patterns you get experience reuse.

- Inheritance is great for code reuse when relationships are stable, but it often makes maintenance harder because changes in a base ripple through all 
- All the design patterns provide a way to let *some part of a system vary independently of all other parts.*

#### OO Basics:
- **Abstraction:** 
	- Defining the what without the how - expressing only the essential contract while hiding implementation details
	- Achieved via `interfaces` or `abstract classes`.
	- Clients depend on the abstraction, not the concrete implementation
  ```ts
interface PaymentProcessor {
  process(amount:number): void;
}
  ```
- **Encapsulation:**
	- Bundling data and behaviour together, restricting direct access to the internals.
	- Achieved by `private/protected` members + controlled getters/setters
	- Protects invariants and enforces controlled usage.
> [!NOTE] NOTE
>Pure getters/setters that just mirror a private field are **not real encapsulation** — they’re effectively the same as making the field public. True encapsulation enforces **invariants** (e.g., no negative balance).

  ```ts
class BankAccount {
  private balance = 0;

  // Controlled deposit — can’t deposit negative money
  deposit(amount: number) {
    if (amount <= 0) throw new Error("Deposit must be positive");
    this.balance += amount;
  }

  // Controlled withdrawal — prevents overdraft
  withdraw(amount: number) {
    if (amount > this.balance) throw new Error("Insufficient funds");
    this.balance -= amount;
  }

  // Read-only access
  getBalance(): number {
    return this.balance;
  }
}

const acct = new BankAccount();
acct.deposit(100);
acct.withdraw(30);
console.log(acct.getBalance()); // 70

// acct.balance = -999; ❌ Not possible
// acct.deposit(-50);  ❌ Throws error
  ```
- **Polymorphism**: 
	- The same operation can take different forms depending on the object it's acting on
	- Achieved via `method overriding`(runtime polymorphism) or `interfaces/generics`(compile-time polymorphism)
  ```ts
abstract class Shape { 
	abstract area(): number; 
}
class Circle extends Shape { 
	constructor(private r: number){
		super();
	} 
	area(){
		return Math.PI*this.r**2;
	} 
}
class Square extends Shape { 
	constructor(private s: number){
		super();
	} 
	area(){
		return this.s*this.s;
	} 
}

const shapes: Shape[] = [new Circle(5), new Square(4)];
shapes.forEach(s => console.log(s.area())); // Circle vs Square, same call
  ```
- **Inheritance**:
	- Creating new classes by reusing and extending existing ones in a `is-a` relationship
	- Provides `code reuse` and hierarchy
	- Can be with or without abstraction
  ```ts
class Animal { 
	eat(){
		console.log("Eating");
	}
}
// Dog IS-A Animal
class Dog extends Animal { 
	bark(){
		console.log("Woof!");
	} 
}
  ```

#### OO Principles:
- Identify the aspects of your application that vary and separate them from what stays the same. In another words, take the parts that vary and encapsulate them, so that you can alter or extend the parts that vary without affecting those that don't.
- Program to an interface, not an implementation. In other words, program to a supertype. The declared type of the variable should be a supertype, usually those variables can be of any concrete implementation of the supertype, which means the class declaring them doesn't have to know about the actual object type.
- HAS-A over IS-A. Favour composition over inheritance. One of the advantage is it lets you encapsulate a family of algorithms/behaviours into their own set of classes, but it also lets you change them in runtime as long as the object you're composing with implements the correct behaviour interface.

#### The Strategy Pattern:
- It defines a family of algorithm, encapsulates each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.
```ts
// Varying aspect: payment method (it can change often)
interface PaymentStrategy {
  pay(amount: number): void;
}

// Different strategies
class CreditCardPayment implements PaymentStrategy {
  pay(amount: number) {
    console.log(`Paid ${amount} with credit card`);
  }
}
class PaypalPayment implements PaymentStrategy {
  pay(amount: number) {
    console.log(`Paid ${amount} with PayPal`);
  }
}
class CryptoPayment implements PaymentStrategy {
  pay(amount: number) {
    console.log(`Paid ${amount} with Bitcoin`);
  }
}

// Context (stable part of system) uses abstraction, not implementation
class Checkout {
  constructor(private payment: PaymentStrategy) {}

  completeOrder(amount: number) {
    this.payment.pay(amount);
  }

  // can swap at runtime
  setPaymentMethod(payment: PaymentStrategy) {
    this.payment = payment;
  }
}

// --- Usage ---
const checkout = new Checkout(new CreditCardPayment());
checkout.completeOrder(100); // Paid 100 with credit card

checkout.setPaymentMethod(new PaypalPayment());
checkout.completeOrder(200); // Paid 200 with PayPal

checkout.setPaymentMethod(new CryptoPayment());
checkout.completeOrder(300); // Paid 300 with Bitcoin
```