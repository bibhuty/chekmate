
> This section covers practices and techniques to keep the boundaries of our software clean

#### Using Third-Party Code:
- **Avoid exposing Map, Record, or raw collections across module boundaries.** Keep them private to a class or a tightly controlled layer. Public APIs should expose domain-specific abstractions (like UserDirectory) rather than generic data structures.
- ❌ Bad boundary
```ts 
function getUserMap(): Map<string, User> {
  return this.userCache;
}
```
- ✅ Good boundary: Here the _essence_ (user lookup) is exposed, not the _implementation_ (Map). You can swap the internals later (DB call, LRU cache, plain array) without breaking clients.
```ts
class UserDirectory {
  private users = new Map<string, User>();

  add(user: User): void {
    this.users.set(user.id, user);
  }

  findById(id: string): User | null {
    return this.users.get(id) ?? null;
  }

  listAll(): User[] {
    return [...this.users.values()];
  }
}
```

#### Learning Test:
- In learning tests we call the third-party API, as we expect to use it in our application. We're essentially doing controlled experiments that check our understanding of that API. The test focus on what we want out of the API
- Not only they are free, they have a positive return on investment. When there are new releases of the third-party package, we run the learning tests to see whether there are behavioural differences.
- Whether you need the learning provided by the learning tests or not, a clean boundary should be supported by a set of outbound tests that exercise the interface the same way the production code does. Without these *boundary tests* to ease the migration, we might be tempted to stay with the old version longer than we should.
- **Example:** This is not testing _our code_, it’s testing how **axios behaves** in scenarios we care about. If axios changes its error-wrapping behaviour or stops auto-parsing JSON in a new release, our learning tests will break immediately, giving us confidence before we upgrade.
```ts
// Learning test for axios HTTP client

import axios, { AxiosResponse } from "axios";

describe("Axios Learning Tests", () => {
  test("should return JSON when response type is default", async () => {
    const response: AxiosResponse = await axios.get("https://jsonplaceholder.typicode.com/todos/1");
    
    // Assert our understanding of axios behavior
    expect(response.status).toBe(200);
    expect(typeof response.data).toBe("object");  // data auto-parsed as JSON
    expect(response.data).toHaveProperty("title");
  });

  test("should throw on 404 by default", async () => {
    try {
      await axios.get("https://jsonplaceholder.typicode.com/does-not-exist");
      fail("Expected axios to throw for 404");
    } catch (err: any) {
      // Axios wraps errors — verify our understanding
      expect(err.response.status).toBe(404);
    }
  });
});
```

#### Using Code That Does Not Yet Exist:
- When integrating with a dependency that doesn’t exist yet (3rd-party API, partner team’s service, future module), don’t block progress.
- Define your own **interface/abstraction** that represents how you _expect_ to use the missing code.
- Build and test your product code against this interface.
- Later, adapt the real implementation behind that interface without changing your core code.
```ts
// ✅ Define interface for future email service
interface EmailService {
  sendEmail(to: string, subject: string, body: string): Promise<void>;
}

// Use it in production code (independent of implementation)
class NotificationService {
  constructor(private emailService: EmailService) {}

  async notifyUser(userEmail: string, message: string) {
    await this.emailService.sendEmail(userEmail, "Notification", message);
  }
}

// Temporary fake implementation (lets us keep coding & testing now)
class FakeEmailService implements EmailService {
  async sendEmail(to: string, subject: string, body: string): Promise<void> {
    console.log(`[FAKE] Email to ${to}: ${subject} - ${body}`);
  }
}

// Later, swap in real provider implementation (e.g., SendGrid, SES)
class SendGridEmailService implements EmailService {
  async sendEmail(to: string, subject: string, body: string): Promise<void> {
    // actual API integration here
  }
}
```