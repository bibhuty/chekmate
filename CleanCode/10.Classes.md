#### Class Organisation:
- A class in organised in this order:
	1. public static constants
	2. private static variables
	3. private instance variables
	4. public instance variables(there's seldom good reason to have them)
	5. public functions 
	6. private utilities called by a public function right after the public function
- We'd like to keep our variables and utility function private, but we're not fanatic about it. Loosening encapsulation is always the last resort we should take.

#### Classes Should Be Small:
- The first rule of class is they should be small. The second rule of classes is they should be smaller than that.
- With functions the size was measured by no of lines. With classes the size is measured by the count of responsibilities.
- If we can't derive a concise name for a class, then it's likely too large. The more ambiguous the class name, the more likely it has too many responsibilities.
- Class names with weasel word like `Processor` or `Manager` or `Super` often hint at unfortunate aggregation of responsibilities.
- We should also be able to write a brief description of the class in about 25 words, without using the words `if`, `and`, `or` or `but`.
```ts
// ❌ Smells bad: ambiguous name, multiple responsibilities
class UserManager {
  private users: Map<string, User> = new Map();

  addUser(user: User) {
    this.users.set(user.id, user);
  }

  findUser(id: string): User | undefined {
    return this.users.get(id);
  }

  // Reporting responsibility
  generateUserReport(): string {
    return JSON.stringify([...this.users.values()]);
  }

  // Notification responsibility
  notifyAll(message: string) {
    for (const user of this.users.values()) {
      console.log(`Sending email to ${user.email}: ${message}`);
    }
  }
}
```

```ts
// ✅ Single responsibility: user storage
class UserRepository {
  private users: Map<string, User> = new Map();

  add(user: User) {
    this.users.set(user.id, user);
  }

  findById(id: string): User | undefined {
    return this.users.get(id);
  }
}

// ✅ Single responsibility: reporting
class UserReporter {
  constructor(private repo: UserRepository) {}

  generateReport(): string {
    return JSON.stringify([...this.repo["users"].values()]);
  }
}

// ✅ Single responsibility: notifications
class UserNotifier {
  constructor(private repo: UserRepository) {}

  notifyAll(message: string) {
    for (const user of this.repo["users"].values()) {
      console.log(`Sending email to ${user.email}: ${message}`);
    }
  }
}
```

#### The Single Responsibility Principle:
- It states that a class or a module should have one, and only one, reason to change.
- We want our systems to be composed of many smaller classes, not a few larger ones. Each small class encapsulates a single responsibility, has a single reason to change, and collaborates with a few other to achieve the desired system behaviour.
#### Cohesion:
- Classes should have a small number of instance variables. Each of the methods of a class should manipulate one or more of those variables. In general the more variables a method manipulates the more cohesive that method is to its class. A class in which each variable is used by each method is maximally cohesive.
- When a class lose cohesion, its better to split them
- Usually breaking a large function into many smaller functions often gives us the opportunity to split several smaller classes out as well. This gives our program a much better organisation and a more transparent structure
```ts
// ❌ Low Cohesion (all-in-one “Utility” class)
class Utility {
  private users: User[] = [];
  private orders: Order[] = [];

  addUser(user: User) {
    this.users.push(user);
  }

  findUserById(id: string): User | undefined {
    return this.users.find(u => u.id === id);
  }

  addOrder(order: Order) {
    this.orders.push(order);
  }

  totalOrders(): number {
    return this.orders.length;
  }
}
```

```ts
// ✅ Split by Responsibility (revealed by cohesion)
class UserDirectory {
  private users: User[] = [];

  addUser(user: User) {
    this.users.push(user);
  }

  findUserById(id: string): User | undefined {
    return this.users.find(u => u.id === id);
  }
}

class OrderRepository {
  private orders: Order[] = [];

  addOrder(order: Order) {
    this.orders.push(order);
  }

  totalOrders(): number {
    return this.orders.length;
  }
}
```

#### Organising for Change:
- Private method behaviour that applies only to a small subset of a class can be a useful heuristic for spotting potential areas for improvement. However, the primary spur for taking action should be the system change itself.
- If there's a class is deemed logically complete, then we need not worry about separating the responsibilities. If we don't need any method addition needed for the foreseeable future, then we should leave that class alone. But as soon as we find ourselves opening up a class, we should consider fixing our design.
```ts
// ❌ Before – Class grows ad-hoc
class Report {
  constructor(private data: string[]) {}

  generateSummary(): string {
    return this.data.join(", ");
  }

  exportAsCsv(): string {
    return this.data.map(d => `"${d}"`).join(",");
  }

  // New requirement: export as JSON
  exportAsJson(): string {
    return JSON.stringify(this.data);
  }
}
```

```ts
// ✅ After – Reorganised for change
class Report {
  constructor(private data: string[]) {}

  getData(): string[] {
    return this.data;
  }

  generateSummary(): string {
    return this.data.join(", ");
  }
}

// New responsibilities split out
interface ReportExporter {
  export(report: Report): string;
}

class CsvExporter implements ReportExporter {
  export(report: Report): string {
    return report.getData().map(d => `"${d}"`).join(",");
  }
}

class JsonExporter implements ReportExporter {
  export(report: Report): string {
    return JSON.stringify(report.getData());
  }
}
```

#### Isolating from Change:
- A client class depending upon concrete details is at risk when those details change. We can introduce interfaces and abstract classes to help isolate the impact of those details.
- **Dependency Inversion Principle:** It says that our classes should depend upon abstraction, not on concrete details. And this principle can help greatly in minimising coupling.
```ts
// ❌ client depends on concrete details
class FileLogger {
  log(message: string) {
    console.log(`[File] ${message}`);
  }
}

class OrderService {
  constructor(private logger: FileLogger) {}

  placeOrder(orderId: string) {
    // business logic...
    this.logger.log(`Order placed: ${orderId}`);
  }
}

// If we later switch to DatabaseLogger or ConsoleLogger,
// OrderService must change → tightly coupled.
```

```ts
// ✅ client depends on abstraction
interface Logger {
  log(message: string): void;
}

class FileLogger implements Logger {
  log(message: string) {
    console.log(`[File] ${message}`);
  }
}

class ConsoleLogger implements Logger {
  log(message: string) {
    console.log(`[Console] ${message}`);
  }
}

class OrderService {
  constructor(private logger: Logger) {}

  placeOrder(orderId: string) {
    // business logic...
    this.logger.log(`Order placed: ${orderId}`);
  }
}

// Now OrderService is isolated from change.
// We can inject any Logger implementation.
```




