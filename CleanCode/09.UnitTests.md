#### The Three Laws of TDD

> These three laws lock you into a cycle that is perhaps 30 seconds long. The tests and the production code are written together, with the tests just a few seconds ahead of the production code.

**First Law:** You may not write a production code until you have written a failing unit test.
**Second Law:** You may not write more of a unit test than is necessary to make it fail (not compiling counts as failing).
**Third Law:** You may not write more production code that is sufficient to pass the current failing test.


#### Keeping Tests Clean:
- Having dirty tests is equivalent to, if not worse than, having no tests.
- *Test code is as important as production code.* It is not a second-class citizen. It requires thought, design, and care. It must be kept as clean as production code.
- An automated suite of unit tests that over the production code is the key to keeping your design and architecture as clean as possible. Tests enable all the -ilities, because ***tests enable fearless change***.
- **Clean test = Readable tests:** Qualities like clarity, simplicity and density of expression makes all the code(here tests) readable. In a test you want to say a lot with a few expressions as possible.
- **BUILD-OPERATE-CHECK Pattern:**
	- ***Step 1:*** Builds up test data
	- ***Step 2:*** Operates on the test data
	- ***Step 3:*** Checks that the operation yielded the expected result
	```ts
	// calculator.ts
	export class Calculator {
	  add(a: number, b: number): number {
	    return a + b;
	  }
	}
	```
	
	```ts
	// calculator-dirty.test.ts
	import { Calculator } from "./calculator";
	
	test("test1", () => {
	  const c = new Calculator();
	  const r = c.add(2, 3);
	  if (r !== 5) {
	    throw new Error("bad result!");
	  }
	});
	```

 ```ts
	// calculator-clean.test.ts
	import { Calculator } from "./calculator";

	describe("Calculator", () => {
		test("should add two numbers", () => {
			// ✅ BUILD
			const calc = new Calculator();
			
			// ✅ OPERATE
			const result = calc.add(2, 3);
			
			// ✅ CHECK
			expect(result).toBe(5);
		});
	});
 ```

#### Domain-Specific Testing Language:
- A **Domain-Specific Testing Language (DSTL)** is a small, expressive “mini-language” you build inside your tests that speaks in the **terms of your problem domain**, not in low-level technical details.
- It hides setup/boilerplate and makes tests **readable as business rules**.
```ts
// ❌ Without DSTL (technical, low-level)
test("withdraw reduces balance when funds are sufficient", () => {
  const account = new BankAccount("123");
  account.deposit(500);
  account.withdraw(200);
  expect(account.getBalance()).toBe(300);
});
```

```ts
// ✅ With DSTL (readable, domain-focused
// A mini testing DSL
function givenAccountWith(balance: number) {
  const account = new BankAccount("123");
  account.deposit(balance);
  return account;
}

function whenWithdraw(amount: number, account: BankAccount) {
  account.withdraw(amount);
  return account;
}

function thenBalanceIs(expected: number, account: BankAccount) {
  expect(account.getBalance()).toBe(expected);
}

// Test now reads like business rule
test("withdraw reduces balance when funds are sufficient", () => {
  thenBalanceIs(300,
    whenWithdraw(200,
      givenAccountWith(500)
    )
  );
});
```

#### A Dual Standard:
- The code within the testing API does have a different set of engineering standards than production code. It must still be simple, succinct, and expressive, but it need not be as efficient as production code.
- There are things that you might never do in a production environment that are perfectly fine in the test environment. Usually they involve issues of memory or CPU efficiency. But they never involve issues of cleanliness.
```ts
// order.ts
export class Order {
  constructor(public items: { price: number; quantity: number }[]) {}

  total(): number {
    // Efficient: single pass, avoids allocations
    return this.items.reduce((sum, i) => sum + i.price * i.quantity, 0);
  }
}
```

```ts
// order.test.ts
import { Order } from "./order";

// Helper: inefficient but expressive
function anOrderWith(...prices: number[]): Order {
  // creates lots of tiny objects (wasteful), but very readable
  return new Order(prices.map(p => ({ price: p, quantity: 1 })));
}

test("should calculate total of multiple items", () => {
  const order = anOrderWith(10, 20, 30); // 🚨 very clear intent
  expect(order.total()).toBe(60);
});
```

#### Rule for a test function:
The best rule is minimise the number of asserts per concept and test just one concept per test function.
```ts
// ❌ Multiple Concepts in One Test**
test("rectangle calculations", () => {
  const rect = new Rectangle(5, 10);

  // Concept 1: Area
  expect(rect.area()).toBe(50);

  // Concept 2: Perimeter
  expect(rect.perimeter()).toBe(30);
});
```

```ts
// ✅ One Concept(Area is correct) with Multiple Asserts
test("rectangle area should be correct", () => {
  const rect = new Rectangle(5, 10);
  const area = rect.area();

  expect(area).toBe(50);                        // direct check
  expect(area).toBe(rect.width * rect.height);  // formula check
  expect(area).toBeGreaterThan(0);              // sanity check
});
```

#### F.I.R.S.T:
- **Fast:** Tests should be fast.
- **Independent:** Tests should not depend on each other
- **Repeatable:** Tests should be repeatable in any env
- **Self-Validating:** Tests should have boolean output
- **Timely:** Tests should be written in timely fashion. Unit tests should be written just before the production code that makes them pass.