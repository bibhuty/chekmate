#### Purpose
Code formatting is about communication, and communication is the professional developer's first order of business. *Getting it working* is not the first order of business. 

#### Vertical Formatting:
- **File Size:** It's desirable(not hard and fast rule) to have a file about 200-500 lines long. 
- **The Newspaper Metaphor:** The source file should be like a newspaper article. The name should be simple but explanatory. The name, by itself, should be sufficient to tell us whether we are in the right module or not. The topmost parts of the source file should provide the high-level concepts and algorithms. Detail should increase as we move downward, until at the end we find the lowest level functions and details in the source file.
  ```ts
❌ Without metaphor (details first, confusing order):
// utils.ts
function normalizeEmail(email: string): string {
  return email.trim().toLowerCase();
}

function validateEmail(email: string): boolean {
  return /\S+@\S+\.\S+/.test(normalizeEmail(email));
}

export function registerUser(email: string, password: string) {
  if (!validateEmail(email)) throw new Error("Invalid email");
  // ...
}
```

```ts
✅ With metaphor (newspaper style):
// userRegistration.ts
// Headline: what this file is about
export function registerUser(email: string, password: string) {
  if (!validateEmail(email)) throw new Error("Invalid email");
  // ... core registration logic
}

// Sub-headline: important mid-level detail
function validateEmail(email: string): boolean {
  return /\S+@\S+\.\S+/.test(normalizeEmail(email));
}

// Fine print: low-level helpers
function normalizeEmail(email: string): string {
  return email.trim().toLowerCase();
}
  ```
- **Vertical Openness Between Concepts:** Nearly all code is rad left to right and top to bottom. Each line represents an expression or a clause, and each group of lines represents a complete thought. Those thoughts should be separated from each other via blank lines.
  ```ts
  // ❌ Without Vertical Openness (cramped)
function processOrder(order: Order) {
  const subtotal = order.items.reduce((s, i) => s + i.price * i.qty, 0);
  const tax = subtotal * 0.1;
  const total = subtotal + tax;
  const invoice = { customerId: order.customerId, items: order.items, subtotal, tax, total };
  if (total > 10000) notifyFinance(order.customerId, total);
  return invoice;
}
```

```ts
// ✅ With Vertical Openness (clear paragraphs)**
 function processOrder(order: Order) {
  // subtotal + totals
  const subtotal = order.items.reduce((s, i) => s + i.price * i.qty, 0);
  const tax = subtotal * 0.1;
  const total = subtotal + tax;

  // invoice object creation
  const invoice = { 
    customerId: order.customerId, 
    items: order.items, 
    subtotal, 
    tax, 
    total 
  };

  // business rule
  if (total > 10000) {
    notifyFinance(order.customerId, total);
  }

  return invoice;
}
  ```
- **Vertical Density:** If openness separates concepts, then vertical density implies close association.
  ```ts
// ❌ Bad (low density, scattered thought)
function calculateTotals(items: Item[]) {
  let subtotal = 0;

  for (const item of items) {
    subtotal += item.price * item.qty;
  }

  const tax = subtotal * 0.1;

  const total = subtotal + tax;

  return { subtotal, tax, total };
}
  ```

```ts
// ✅ Good (dense where it should be)
function calculateTotals(items: Item[]) {
  let subtotal = 0;
  for (const item of items) {
    subtotal += item.price * item.qty;
  }
  const tax = subtotal * 0.1;
  const total = subtotal + tax;
  return { subtotal, tax, total };
}
```
- **Vertical Distance:** Concepts that are closely related should be kept vertically close to each other. Clearly this rule doesn't work for concepts that belongs to separate files. But then closely related concepts should not be separated into different files unless you have a very good reason. Indeed, this is one of the reasons that protected variables should be avoided.
	- **Variable Declaration:** 
		- Variables should be declared as close to their usage as possible
		- Control variables for loops should usually be declared within the loop statement
		- In rare cases a variable might be declared at the top of a block or just before a loop in a long-ish function.
	```ts
function processOrders(orders: Order[]) {
  // declare variable close to usage
  const today = new Date();

  for (let i = 0; i < orders.length; i++) {  // loop variable inside loop
    const order = orders[i];                 // declared right before use
    const total = calculateTotal(order);     // no early unused variables

    if (total > 10000) {
      notifyFinance(order.customerId, total, today);
    }
  }

  // rare case: declare once, used later in a loop
  let grandTotal = 0;
  for (const order of orders) {
    grandTotal += calculateTotal(order);
  }
  return grandTotal;
}
```
	- **Instance Variables:** They should be declared at the top of the class
	- **Dependent Functions:** They should follow the newspaper metaphor where ever possible.
	- **Conceptual Affinity:** They are based on certain criteria based on direct dependence, such as one function calling another, or a function using a variable. It can also be caused by group of functions perform similar operations. The stronger the affinity, the less vertical distance there should be between them.
	```ts
// Details: discount helpers grouped together
function applySeasonalDiscount(total: number): number {
  return total * 0.9; // 10% off
}

function applyLoyaltyDiscount(total: number, years: number): number {
  return years > 5 ? total * 0.85 : total; // 15% off
}

function applyBulkDiscount(total: number, quantity: number): number {
  return quantity > 100 ? total * 0.8 : total; // 20% off
}
	```

#### Horizontal Formatting:
The old Hollerith limit is 80 characters long but considering today's norm let's not increase the line beyond 100 characters and in rare cases 120. Beyond that is considered careless.
```ts
// ❌ Careless: too long
const user = { id: 123, name: "Alice", email: "alice@example.com", address: "123 Long Street, Big City, Country" };

// ✅ Wrapped cleanly
const user = {
  id: 123,
  name: "Alice",
  email: "alice@example.com",
  address: "123 Long Street, Big City, Country",
};
```
- **Horizontal Openness and Density:** We use horizontal white space to associate things that are strongly related and disassociate things that are weakly related. Another use is to accentuate the precedence of operators.
  ```ts
function calculateScore(correct: number, total: number): number {
  // density: function args are close, type annotations stick to names
  const ratio = correct / total;

  // openness: spaces around operators separate weakly related parts
  const weighted = (ratio * 100) + 5;

  // openness for readability in compound conditions
  if (ratio > 0.9 && total > 50) {
    return weighted + 10;
  }

  return weighted;
}
  ```
- **Breaking Indentation:** Its sometimes tempting to break the indentation rule for short `if` statement, short `while` loop, or short functions. Its better to be consistent in those cases too.
```ts
// ❌ Tempting but inconsistent
if (isReady) doWork();

// ✅ Consistent
if (isReady) {
  doWork();
}
```
- **Dummy Scopes:** Sometimes body of a `while` or `for` statement is dummy and in such case indenting the dummy body gives clarity.
  ```ts
// Spin until resource becomes available
while (!isResourceAvailable()) {
  ; // dummy body — semicolon indented for clarity
}

// Skip over whitespace in a string
for (let i = 0; i < input.length && input[i] === " "; i++) {
  ; // dummy body clearly shown
}
  ```