
> Master programmers think of systems as stories to be told rather than programs to be written

#### Small!
- The first rule of functions is that they should be small. The second rule of functions is that they should be smaller than that.
- Functions should hardly ever be 20 lines long
- Blocks within `if`, `else`, `while` etc. should be one line long
- Functions should not be large enough to hold nested structures. The indent level of a function should not be greater than one or two.

#### Do One Thing
- ***Functions should do one thing. They should do it well. They should do it only.***
- If a function does only those steps that are one level below the state name of the function, then the function is doing one thing. It'll feel like the body reading like a **Table of Content**
- Another way to know if a function is doing more than "one thing" is if you can extract another function from it with a name that is not merely a restatement of its implementation.
- In order to make sure our functions are doing "one thing" we need to make sure that the statements within our function are all at the same level of abstraction. 
```ts
  
/*
	Function doing a lot of things
*/
function generateInvoice(order: Order): Invoice {
	// Low-level: iteration & math
	let subtotal = 0;
	for (const item of order.items) {
	subtotal += item.price * item.quantity;
	}
	const tax = subtotal * 0.1;
	const total = subtotal + tax;
	
	// Mid-level: object creation
	const invoice = {
	customerId: order.customerId,
	items: order.items,
	subtotal,
	tax,
	total,
	};
	
	// High-level: side-effect (policy/business rule)
	if (total > 10000) {
	notifyFinance(order.customerId, total);
	}
	
	return invoice;
}
/*
	Function doing one thing
*/
function generateInvoice(order: Order): Invoice {
  const items = mapItems(order);
  const totals = calculateTotals(items);
  return createInvoice(order.customerId, items, totals);
}
  ```

#### Switch Statements/ Multiple if-else chain
- Its hard to avoid them but we can make sure that each of the statement is buried in a low-level class and never repeated. We can do it with polymorphism.
```ts
// Switch-based payroll(Messy)
function computePayroll(employees: Employee[]): PayBreakdown[] {
  return employees.map(e => {
    switch (e.kind) {
      case "FullTime": ...
      case "Contract": ...
      ...
      default:
        throw new Error(`Unknown employee kind: ${(e as any).kind}`);
    }
  });
}

function deliverPay(employees: Employee[]) {
  return employees.map(e => {
    switch (e.kind) {
      case "FullTime": ...
      case "Contract": ...
      ...
      default:
        throw new Error(`Unknown employee kind: ${(e as any).kind}`);
    }
  });
}


// Moving the statements to low level class(Elegant)
interface PayBreakdown { /* ... */ }

interface Employee {
  id: string; name: string;
  computePay(): PayBreakdown;        // behavior lives with the type
  deliveryPay(): void;
}

class FullTime implements Employee {
  constructor(public id: string, public name: string, private salary: number) {}
  computePay(): PayBreakdown { /*...*/ return /*...*/ }
}

class Contract implements Employee {
  constructor(public id: string, public name: string, private rate: number, private hours: number) {}
  computePay(): PayBreakdown { /*...*/ return /*...*/ }
}

function computePayroll(employees: Employee[]) {
  return employees.map(e => e.computePay()); // stays closed to change
}
```

#### Use Descriptive Name:
- The smaller and more focused  a function is, the easier it is to choose a descriptive name
- A long descriptive name is better than a short enigmatic name. A long descriptive name is better than a long descriptive comment. Use a naming convention that allows multiple words to be easily read in the function names, and then make use of those multiple words to give the function a name that says what is does.

#### Function Arguments(most to least preferred):
- **Niladic Function:** Function with 0 args
- **Monadic Function**: Function with 1 arg. Its typically used in cases below:
	- Asking a question: `const fileExists = (fileName:string):boolean=>{...}`
	- Operating on that args, transforming it into something and returning it: `const getFileObject = (fileName:string):object=>{...}`
	- Events, returns void: `const emitToTelemetry = (data:object):void=>{...}`
- **Dyadic Function**: Function with 2 args
	- They aren't evil and we've to write them. We should be aware that it comes with a cost we should be aware and should find mechanisms to convert it into monads.
- **Triadic Function**: Function with 3 args
	- Significantly harder to understand and should be avoided as much as possible
- **Polyadic Function**: Function with more than 3 args. It required special justification and should not be used anyway.
- **Argument Objects**: When a function seems to need more than 2 or 3 arguments, it is likely that some of those arguments ought to be wrapped into a class of their own. 
	- ```ts
		const makeCircle = (x:number, y:number, radius:number)=>{...};
		const makeCircle = (centre:Point, radius: number)=>{...} 
		// What we did above is not cheating but a nice way of 
		// conceptualising similar data points
	 ```
- **Argument Lists**: If the variable arguments are all treated identically, then they are equivalent to a single argument. They can be monads, diads or triads. It'd be a mistake to give them more arguments than that.
	- ```ts
		interface Math {
			max(...values: number[]): number; // monadic function
		}
	  ```
- Choosing good ***keyword*** can enhance a function name e.g. `assetEquals(expected, actual)` renamed to `assertExpectedEqualsActual(expected, actual)` avoids double-take during implementation.
- Arguments are harder in the testing point of view. Imagine the difficulty of writing all the test cases to ensure that all the various combinations of the arguments work properly.
- **Flag Arguments** are ugly and is a truly terrible practice. It simply states that the function does multiple things according to the flag as opposed to a function should do only one job well. 

#### Side Effects and Output Arguments:
- Side effects are lies. They must be avoided at all the costs
- In general output arguments should be avoided. If your function must change the state of something, have it change the state of its owning object.
- Anything that forces you to check the function again to understand what's happening is ***double-take***. Its a cognitive break and should be avoided.

#### Command Query Separation:
- Function should either do something or answer something but not both. Either your function should change the state of an object, or it should return some information about that object. Doing both often leads to confusion.

#### Exceptions:
- Returning error codes from command functions is a subtle violation of command query separation. It promotes command being used as an expressions in the predicates of `if` statement. e.g. `if(deletePage(page) == E_OK)`
- Functions should do one thing. Error handling is one thing. Thus, a function that handles errors should do nothing else.
- `ErrorCode` enum in a centralised form is a ***dependency magnet*** often requiring redeployment or recompilation across services. We should use `Exceptions` instead since they are derivatives of `Exception` class and can be added without forcing recompilation or redeployment.
```ts
// ❌ Dependency magnet
enum ErrorCode { OK, NotFound, OverLimit }

// ✅ Exception
class OverLimitError extends Error {
	constructor(public limit: number, public attempted: number) {
		super(`Over limit: attempted ${attempted}, limit ${limit}`);
	}
}
```

#### Structured Programming:
Every function, and every block within a function, should have one entry and one exit. Following these rules means that there should only be one `return` statement in a function, no `break` or `continue` statements in a loop.
- This is only beneficial in larger functions
- For smaller functions, the occasional multiple `return`, `break` or `continue` statement does no harm and can be sometimes more expressive than the single-entry, single-exit rule.