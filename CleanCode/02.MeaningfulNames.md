#### Use Intention-Revealing Names
- A variable should tell you why it exists, what it does, and how it is used. If a name requires a comment, then the name doesn't reveal its intent.
- Its perfectly fine to change the name of a variable for a better name
- Example:
  ``` ts
  /*
   * Variable not revealing its intentions standalone
   */
  let d: number; // elapsed time in days
  
  
  /*
   * Variable revealing its intentions standalone
   * They specify what is being measured and the unit of the same
   */
  let elapsedTimeInDays: number;
  let daysSinceCreation: number;
  let daysSinceModification: number;
  let fileAgeInDays: number;
  ```

#### Avoid Disinformation:
- We should avoid words whose entrenched meanings vary from our intended meaning
  ```ts
  // Intention: Grouping of accounts
  
  // Bad naming
  let accountList: string[];
  
  // Good naming
  let accountGroup: string[];
  let bunchOfAccounts: string[];
  let accounts: string[];
  ```
- Beware of using names which vary in small ways:
  ```ts
  const account = getAccount();
  const accounts = getAccounts();
  
  let custId;    // abbreviated
  let customerId; // full form
  ```

#### Make meaningful distinctions:
- It is not sufficient to add number series or noise words, even thought the compiler is satisfied.
- **Number-series naming(a1, a2,...., an):**
  ```ts
  const copyChars = (a1:number[], a2:number[]) => {...}
  // reads pretty well when the 2 variables are source and destination
  ```
- **Noise words:**
  ```ts
  class Product{}
  class ProductInfo{}
  class ProductData{}
  
  
  let moneyAmount, money;
  let customerInfo, customer;
  let accountData, account;
  let theMessage, message;
  ```

#### Use Pronounceable Names:
```ts
let genymdhms: Date; // generation date year month day hour minute second

let generationTimestamp: Date;
```
#### Use Searchable Names:
- Single-letter names and numeric constants have a particular problem in that they are not easy to locate across a body of text.
- Longer name trump shorter names, and any searchable name trumps a constant in code
- Single letter names can ONLY be used as a local variables inside short methods. *The length of a name should correspond to the size of its scope.* e.g.: `MAX_CLASSES_PER_STUDENT` instead of just the number 7

#### Avoid Encodings:
- Encoding ***type*** or ***scope*** information into names simply adds an extra burden of deciphering.
  ```ts
  let m_dsc:string; // scope encoding
  let phoneString: PhoneNumber; // type encoding
  ```
- There are sometimes special case of encoding. e.g. either encode the interface or the implementation. Encoding implementation is preferred
  ```ts
  interface PaymentService {}
  class PaymentServiceImpl implements PaymentService {}
  ```

#### Avoid Mental Mapping
- Classes and objects should have noun or noun phrase names like `Customer`, `WikiPage`, `Account`, and `AddressParser`. Avoid words like `Manager`, `Processor`, `Data` or `Info` in the name of a class. A class name should not be a verb.
  ```ts
  // Examples in the format where 
  
  // Line 1: Words to avoid
  // Line 2: Alternate to the same
  
  let CustomerData;
  let CustomerProfile, CustomerRecord;
  
  let UserInfo;
  let UserDetails;
  
  let ReportManager;
  let ReportScheduler, ReportExporter;
  
  let PaymentProcessor;
  let PaymentAuthoriser, PaymentGateway;
  ```
- Methods should have verb or verb phrase names like `postPayment`, `deletePage` or `save`.
- When constructors are overloaded, use static factory methods with names that describe the arguments.
  ```ts
  let fulcrumPoint: Complex = Complex.FromRealNumber(23.0);
  // as opposed to
  let fulcrumPoint: Complex = new Complex(23.0);
  ```
- Say what you mean. Mean what you say
  ```ts
  //use
  kill();
  // opposed to 
  whack();
  
  
  // use
  abort()
  // opposed to
  eatMyShorts()
  ```
- Pick one word for one concept and stick with it. e.g. `fetch`, `retrieve`, `get` have equivalent meaning and can be used for the same concept but we need to restrain and stick to one of them.
- Avoid using same word for 2 purposes. e.g. if `add` method is used for the behaviour of concatenating 2 values. When the use case comes to add an existing value into a collection, instead of naming it `add`, we can go for `insert` or `append` 
- In general **solution domain name** *(computer science terms)* like `AccountVisitor` where ever possible. In case there's no such name possible let's fallback to **problem domain name** *(domain specific terms)*. The code that has more to do with *problem domain concepts* should have names drawn from problem domains too.
- Place names in context by enclosing them in well-named classes, functions or namespaces. When all else fails, then prefixing the name may be necessary last resort.
  ```ts
  // Bad design
  let addrFirstName: string;
  let addrLastName: string;
  let addrStreet: string;
  let addrCity: string;
  let addrZip: string;

  // Good design
  class Address {
    firstName: string;
    lastName: string;
    street: string;
    city: string;
    zip: string;
  }
  
  // For the case where they can't be grouped logically, 
  // its perfectly fine to append with prefix
  let configDbUrl: string;
  let configApiKey: string;
  ```
  - Don't add unnecessary context. Shorter names are generally better than longer ones, so long as they are clear. Add no more context to a name than is necessary. e.g. The names `accountAddress` and `customerAddress` are fine names for instances of the class `Address` but could be poor names for classes. If there's an addition of MAC Address then would rename `Address` to `PostalAddress` and a new class `MACAddress` will be introduced.