#### Data Abstraction:
Hiding implementation details is not just a matter of putting a layer of functions between the variables. Hiding implementation is about abstraction! A class does not simply push its variables out through getters and setters. Rather it exposes abstract interfaces that allows its users to manipulate the *essence* of the data, without having to know its implementation.

- **Example 1:**
```ts
// ❌ Negative Example – exposing implementation
class Point {
  constructor(private _x: number, private _y: number) {}

  getX(): number { return this._x; }
  getY(): number { return this._y; }
  setX(x: number): void { this._x = x; }
  setY(y: number): void { this._y = y; }
}

// client code
const p = new Point(2, 3);
p.setX(p.getX() + 5);   // knows too much about internal representation
```

```ts
// ✅ Positive Example – abstracting behavior
class Point {
  constructor(private x: number, private y: number) {}

  translate(dx: number, dy: number): void {
    this.x += dx;
    this.y += dy;
  }

  distanceFromOrigin(): number {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
}

// client code
const p = new Point(2, 3);
p.translate(5, 0);   // intent: move point by (5,0)
```
- **Example 2:**
```ts
// ❌ Concrete Vehicle
interface Vehicle{
	getFuelTankCapacityInGallons(): number;
	getGallonsOfGasoline(): number;
}

// ✅ Abstract Vehicle
interface Vehicle{
	getPercentFuelRemaining(): number;
}
```

#### Data/Object Anti-Symmetry:
- Objects hide their data behind abstractions and expose functions that operate on that data. Data structure expose their data and have no meaningful functions.
- **Procedural Code:** 
	- Keeping data and behaviour separate. 
	- In other words, procedure happens on data. It makes it easy to add new functions without changing the existing data structures.
	- Its hard to add new data structures here because all the existing functions needs to change.
	```ts
// data structures
class Rectangle {
  constructor(public width: number, public height: number) {}
}

class Square {
  constructor(public side: number) {}
}

class Circle {
  constructor(public radius: number) {}
}

// Imagine adding the new class defined below
// It'll touch all the functions present in 
// Gemoetry class. It's hard to add new class
// in procedural code
//class Triangle implements Shape {
//  constructor(public a: number, public b: number, public c: number) {}
//}

// central "geometry" utility
class Geometry {
  static area(shape: Rectangle | Square | Circle): number {
    if (shape instanceof Rectangle) {
      return shape.width * shape.height;
    } else if (shape instanceof Square) {
      return shape.side * shape.side;
    } else if (shape instanceof Circle) {
      return Math.PI * shape.radius * shape.radius;
    } else {
      throw new Error("Unknown shape");
    }
  }
  // Imagine a new requirement comes to add perimeter
  // We can add it easily without chainging any of the
  // existing class
  static perimeter(shape: Rectangle | Square | Circle): number {
    if (shape instanceof Rectangle) {
      return 2 * (shape.width + shape.height);
    } else if (shape instanceof Square) {
      return 4 * shape.side;
    } else if (shape instanceof Circle) {
      return 2 * Math.PI * shape.radius;
    } else {
      throw new Error("Unknown shape");
    }
  }
}
	```
- **Object Oriented:** 
	- Hide the data and expose the behaviour.
	- It makes it easy to add new classes without changing existing functions.
	- Its hard to add new functions because all the existing classes must change.
	```ts
interface Shape {
  area(): number;
  // Imagine adding a new function defined below. 
  // It'll touch all the class. Its hard to add new
  // functions in case of OO code
  // perimeter(): number;
}

class Rectangle implements Shape {
  constructor(public width: number, public height: number) {}

  area(): number {
    return this.width * this.height;
  }
}

class Square implements Shape {
  constructor(public side: number) {}

  area(): number {
    return this.side * this.side;
  }
}

class Circle implements Shape {
  constructor(public radius: number) {}

  area(): number {
    return Math.PI * this.radius * this.radius;
  }
}
class Triangle implements Shape {

  constructor(public a: number, public b: number, public c: number) {}

  area(): number {
    const s = (this.a + this.b + this.c) / 2;
    return Math.sqrt(s * (s - this.a) * (s - this.b) * (s - this.c));
  }
}
	```

> Mature programmers know that everything is an object is a myth. Some times you really do want simple data structures with procedures operating on them.

#### The Law of Demeter:
- Module should not know the innards of the **`objects`** it manipulates.
- A method `f` of a class `C` should only call the methods of these:
	- `C`
	- An object created by `f`
	- An object passed as an argument to `f`
	- An object held in an instance variable of `C`
- The method should not invoke methods on objects that are returned by any of the allowed functions. In short it should avoid *train wreck*.
```ts
// ❌ Non-compliant
// train wreck code assuming ctxt, Options, ScratchDir 
// are objects(not data structures)
const outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
// ✅ Compliant (delegation)
const outputDir = ctxt.getOutputDirPath();

// In case they are data structures its absolutely fine
// to write, no Law of Demeter violated
const outputDir = ctxt.options.scratchDir.absolutePath;
```

#### Hybrids:
- The confusion of either to chose `object` or `data structure` leads to unfortunate hybrid structures that are neither of them creating confusion. They are worst of both worlds. We should avoid creating them.
```ts
class HybridRectangle {
  // data fields (with getters/setters)
  constructor(private _width: number, private _height: number) {}

  get width(): number { return this._width; }
  set width(value: number) { this._width = value; }

  get height(): number { return this._height; }
  set height(value: number) { this._height = value; }

  // also behavior methods
  area(): number {
    return this._width * this._height;
  }

  perimeter(): number {
    return 2 * (this._width + this._height);
  }
}
```
- ***Active Record*** (ORM entities with both fields + save/delete) is a common hybrid — data + persistence + behaviour. Avoid unless in simple CRUD apps.