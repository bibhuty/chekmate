
>**Error handling must never bury the happy path.** If the core intent of the function is hard to see because of error checks and try/catch noise, the error handling is obscuring the logic and should be refactored out.

> **Error handling is a separate concern.** Robust code comes from handling errors deliberately, but error-handling logic must be isolated so the main flow stays clear and independently readable.
#### Use Exceptions Rather Than Return Codes
```ts
// ❌ Using return codes
function deleteFile(path: string): number {
  if (!fs.existsSync(path)) return -1;   // error code
  fs.unlinkSync(path);
  return 0; // success code
}

// client code
const result = deleteFile("report.txt");
if (result === -1) {
  console.error("File not found");
}
```

```ts
// ✅ Using exceptions
function deleteFile(path: string): void {
  if (!fs.existsSync(path)) {
    throw new Error("File not found");
  }
  fs.unlinkSync(path);
}

// client code
try {
  deleteFile("report.txt");
} catch (e) {
  console.error(e.message);
}
```

#### Write Your `Try-Catch-Finally` Statement First:
- Try to write tests that force exceptions, and then add behaviour to your handler to satisfy your tests. This will cause you to build the transaction scope of the `try` block first and will help you maintain the transaction nature of that scope.
```ts

// STEP 1: Start with a test that forces an exception //
// FileService.test.ts
import { FileService } from "./FileService";

test("should throw when trying to delete a missing file", () => {
  const fs = new FileService();
  expect(() => fs.delete("missing.txt")).toThrow("File not found");
});


// STEP 2: Minimal implementation to make it pass //
// FileService.ts
import * as fs from "fs";

export class FileService {
  delete(path: string): void {
    if (!fs.existsSync(path)) {
      throw new Error("File not found"); // forced by test
    }

    try {
      fs.unlinkSync(path);
    } catch (e) {
      throw new Error("Unable to delete file"); // refine behavior later
    }
  }
}

// STEP 3: Add another test to refine behavior //
// FileService.test.ts
test("should throw a clear error when deletion fails unexpectedly", () => {
  const fs = new FileService();
  // simulate failure (e.g., no permissions)
  jest.spyOn(require("fs"), "unlinkSync").mockImplementation(() => {
    throw new Error("EPERM");
  });

  expect(() => fs.delete("locked.txt")).toThrow("Unable to delete file");
});
```

#### Use Unchecked Exception:
- The price of checked exception is ***Open/Close Principle*** violation.
- Checked exceptions can sometimes be useful if you are writing a critical library. You must catch them. But in general application development the dependency cost outweigh the benefits.
- Each exception you throw should provide enough context to determine the source and location of an error.
```ts
// Library code – throws meaningful, context-rich exception
class FileService {
  delete(path: string): void {
    if (!fs.existsSync(path)) {
      throw new Error(`File not found: ${path}`);
    }
    fs.unlinkSync(path);
  }
}

// Client code – only catches when it needs to
function processFile(path: string) {
  const service = new FileService();
  try {
    service.delete(path);
    console.log("File deleted");
  } catch (e) {
    console.error("Delete failed:", e.message);
    
    // above is not forced to handle every possible error
    // type like below statement, imagine one more type  
    // error added SocketException, you have to go and add 
    // one more else if statement, that's a violation of 
    // open/close principle
    
    /* 
	if (e instanceof FileNotFoundError) {
	  console.error(e.message);
	}
	*/
  }
}
```
#### Define Exception Classes In Terms of Caller Needs:
- When we define exception classes in an application, our most important concern should be how they are caught.
- Often a single exception class is fine for a particular area of code. The information sent with the exception can distinguish the errors. Use different classes only if there are times when you want to catch one exception and allow the other one to pass through.
```ts
class UserNotFoundError extends Error {
  constructor(id: string) {
    super(`User not found: ${id}`);
    this.name = "UserNotFoundError";
  }
}

class UserValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "UserValidationError";
  }
}

// caller
try {
  const user = findUser("123");
} catch (e) {
  if (e instanceof UserNotFoundError) {
    console.warn("Handle missing user gracefully");
  } else if (e instanceof UserValidationError) {
    console.error("Invalid data:", e.message);
  } else {
    throw e; // propagate others
  }
}
```

#### Define the Normal Flow:
Error handling must not bury the **happy path**. Make the main behaviour obvious; handle expected “absence”/variants as part of the normal control flow. Reserve exceptions for truly exceptional failures.
```ts
// ❌ Obscures logic (exception used for expected flow)
function getUserName(id: string): string {
  try {
    const user = db.findUser(id); // returns undefined when missing
    if (!user) throw new Error("Not found");
    return user.name;
  } catch {
    return "Guest"; // fallback hidden in exception path
  }
}

// ✅ Normal flow (special case at function level)
function getUserName(id: string): string {
  const user = db.findUser(id);
  return user ? user.name : "Guest"; // fallback is explicit, happy path is clear
}
```


> [!NOTE] SPECIAL CASE PATTERN
> You create a class or configure an object so that it handles a special case for you. When you do, the client code doesn't have to deal with the exceptional behaviour. That behaviour is encapsulated in the special case object.

#### NULL Handling:
This is one of the most important thing which invites error.
- **Returning NULL:** If you are tempted to return `null` from a method, consider throwing an exception or returning a `SPECIAL CASE` object instead. If you are calling a `null` returning method from a third party API, consider wrapping that method with a method that either throws an exception or returns a special case object. 
```ts
// ❌ Bad (returns null, caller forced to handle everywhere)
function findUser(id: string): User | null {
  return db[id] ?? null;
}

// caller
const user = findUser("123");
if (user !== null) {
  sendEmail(user.email);
}
```

```ts
// ✅ Good (special case object)
const GuestUser: User = { id: "guest", name: "Guest", email: "guest@example.com" };

function findUser(id: string): User {
  return db[id] ?? GuestUser;
}

// caller — no null check
sendEmail(findUser("123").email);
```

- **Passing NULL:** Passing `null` into method is the worst thing we can do. In most programming languages there is no good way to deal with a `null` that is passed by a caller accidentally. Because this is the case, the rational approach is to forbid passing `null` by default. When you do, you can code with the knowledge that a `null` in an argument list is an indication of problem, and end up with far fewer careless mistake.
```ts
// ❌ Bad (accepts null, fragile contract)
type Point = { x: number; y: number };

function euclideanDistance(p1: Point | null, p2: Point | null): number {
  if (!p1 || !p2) {
    throw new Error("Points must not be null"); // defensive but noisy
  }
  return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
}

// caller can accidentally pass null
euclideanDistance(null, { x: 0, y: 0 }); // runtime failure
```

```ts
// ✅ Good (forbid null by contract)
type Point = { x: number; y: number };

function euclideanDistance(p1: Point, p2: Point): number {
  return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
}

// compiler now enforces non-null
const a: Point = { x: 3, y: 4 };
const b: Point = { x: 0, y: 0 };

euclideanDistance(a, b); // ✅ safe
```